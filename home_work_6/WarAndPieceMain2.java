package homework.home_work_6;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.*;

/**
 * 2.2 Найти в тексте топ N (настраиваемое значение) слов и вывести количество этих слов используя Map и List. Отсортировать по количеству. Распечатать в консоль.
 * Пример: Война - 200 раз, Мир - 100 раз и так далее. Знаки препинания, пробелы и переводы строк - это не слова.
 * Более подробное описание задачи, для понимания чего я хочу: Для решения данной задачи необходимо прочитать текстовый файл  и поместить текст из
 * данного текстового файла в строку.  Далее данную строку необходимо обработать таким образом чтобы из неё можно было бы считывать слова.
 * Далее каждое полученное слово поместить как ключ в Map, а количество повторений в тексте ставить как значение. Для того чтобы это работало
 * вам необходимо постоянно проверять наличие ключа в Map, и если нужный нам ключ уже присутсвует в нашей коллекции то мы должны увеличить уже
 * имеющееся значение в коллекции на еденицу. После наполнения данной коллекции мы получим набор слов и их количество в тексте. Далее нам нужно
 * придумать как отсортировать получившуюся коллекцию но к сожалению непосредственно эту коллекцию отсортировать не получится, придётся создавать
 * для этого List и наполнять лист Entry из Map. В итоге из получившегося отсортированного набора данных вывести первые N записей.
 * 3. Написать интерфейс ISearchEngine. Это будет интерфейс в котором будут методы:
 * 3.1 long search(String text, String word) - Метод возвращает информации о количестве раз которое встречается слово в тексте. Первый параметр текст
 * в котором ищем, второй параметр что ищем в тексте.
 * 4. Реализовать интерфейс ISearchEngine:
 * 4.1 Написать класс EasySearch. Реализовать поиск используя метод indexOf из класса String. В данной реализации запрещено использовать регулярные выражения
 * в любом виде, для любых задач. Данный класс ищет слова с учётом регистра.
 * 4.2* Написать класс RegExSearch реализующий интерфейс ISearchEngine. Реализовать поиск при помощи класса Matcher. Данный класс ищет слова с учётом регистра.
 * 4.3* Написать декоратор SearchEnginePunctuationNormalizer для ISearchEngine который будет удалять нежелательные символы. Любые знаки препинания, лишние пробелы
 * и например переводы строк.
 * 4.4* Написать декоратор для ISearchEngine который будет позволять искать данные без учёта регистра.
 * Более подробное описание задачи, для понимания чего я хочу:  Тут можно пойти на хитрость, данный класс может просто приводить весь текст и передаваемое
 * слово к нижнему регистру но тут возникает вопрос как данный класс может помочь для RegExSearch. Класс RegExSearch в своей реализации использует регулярные
 * выражения и в случае с регулярными выражениями есть возможность указать свойство CASE_INSENSITIVE для выражение и оно и так станет не чувствительно к регистру.
 * Для того чтобы тут что-то оптимизировать можно воспользоваться оператором instanceof и вычислить таки какого класса нам передали объект ISearchEngine.
 * Данная практика является нежелательной но при этом в некоторых случаях очень эффективной.
 * 4.5** Написать декоратор SearchEngineCaseNormalizer для ISearchEngine который будет приводит все слова к единому падежу. Что позволит учитывать их как одинаковые
 * слова. Например после работы данного класса текст "бабушка бабушке бабушку" уже будет выдавать: "бабушка - 3". Падеж можно настроить при помощи конструктора.
 * 5. Используя реализации интерфейса ISearchEngine вывести информацию как часто встречаются слова "война", "и" (как союз), "мир" вне зависимости от регистра.
 */

public class WarAndPieceMain2 {
    public static void main(String[] args) {

        String book;
        StringBuilder stringBuilder = new StringBuilder();

//        считываем текст из файла "Война и мир_книга.txt"
        try (Reader reader = new FileReader("Война и мир_книга.txt");
             BufferedReader bufferedReader = new BufferedReader(reader)) {
            while (bufferedReader.ready()) {
                stringBuilder.append(bufferedReader.readLine());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

//        сохраняем текст в строку
        book = stringBuilder.toString();

//        с помощью регулярного выражения удаляем все знаки препинания и др.
        String clearBook = book.replaceAll("[)(|,;.:!?\"-*1234567890=]+", "");

//        создаем массив строк, с помощью метода split делим нашу строку на подстроки по пробелу
        String[] words = clearBook.split(" +");

//        помещаем все строки из массива в Map
        Map<String, Integer> mapWords = new HashMap<>();

        for (int i = 0; i < words.length; i++) {
            if (!mapWords.containsKey(words[i])) {
                mapWords.put(words[i], 1);
            } else {
                mapWords.put(words[i], mapWords.get(words[i]) + 1);
            }
        }
        System.out.println(mapWords);


    }
}
